
# Лабораторна робота №3

## Завдання 1

Послідовно виконуємо команди для завдання (рисунок 1).

<p align='center'>
    <img src="1.png">
</p>
<p align='center'>
    Рисунок 1 - експериментування з лімітом ресурсів відкритих файлів
</p><br>

<p style="color: red; font-weight: bold">
Оскільки завданням передбачено виконувати команди в docker-контейнері, то ми вже маємо root-права.
</p>

> **Пояснення**
>
> Спочатку ми передивляємось поточний ліміт (софт ліміт) на кількість відкритих файлів. Потім ми робимо теж саме тільки з префіксами для софт та хард лімітів. І там, і там однакові результати. Потім ми встановлюємо ліміт на 3000 і повторюємо дії. Бачимо що з софт лімітом, змінився ще й хард ліміт. При спробі встановити обмеження на 3001, ми отримуємо помилку. Далі встановлюємо ліміт на 2000, виводмо значення і все нормально. Пробуємо знову встановити 3000 і помилка. **Можемо помітити певну закономірність: контейнер може змінювати ліміт ресурсів відкритих файлів через ulimit тільки вниз і не може підняти вище встановленого значення !.**

<br>
<hr>

## Завдання 2

perf (Performance Counters for Linux) — це утиліта для аналізу продуктивності процесора, ядра та користувацьких процесів у Linux. Вона дозволяє збирати дані про CPU, кеш, системні виклики, блокування потоків та багато іншого. Для виконання завдання, напишемо програму (рисунок 2), яка використовує велику кількість обчислень, створюючи навантаження на процесор. Потім виміряємо продуктивність за допомогою perf (рисунок 3).<br><br>

<p align='center'>
    <img src="2.png">
</p>
<p align='center'>
    Рисунок 2 - цикл для навантаження процесора
</p><br>

<p align='center'>
    <img src="3.png">
</p>
<p align='center'>
    Рисунок 3 - вивід perf
</p><br>

Бачимо, що процес sleep 5 виконувався процесором 5.6 секунд, відбулося лише 8 перемикань контексту, тобто процес не дуже часто витіснявся з ЦП. Процес не мігрував між ядрами ЦП і не мав жодних page fault, тобі він не використовув swap.
<br><br>
<hr>

## Завдання 3

Напишемо програму згідно завдання (рисунок 4, 5).

<p align='center'>
    <img src="4.png">
</p>
<p align='center'>
    Рисунок 4 - програма, що імітує кидання кубика
</p><br>

<p align='center'>
    <img src="5.png">
</p>
<p align='center'>
    Рисунок 5 - результат виконання програми
</p><br>

Ми встановили ліміт розміру файлу в 10 * 1024 байтів. Після компіляції бачимо файл, куди записались випадкові числа від 1 до 6. Потім перевіряємо розмір файлу і бачимо 10K, тобто ми коректно обробили ситуацію перевищення ліміту.
<br><br>

<hr>

## Завдання 4

Напишемо програму, що імітує лотерею згідно з вимогами до завдання (рисунок 6), скомпілюємо та запустимо її, щоб впевнитись в коректності роботи програми (рисунок 7).

<p align='center'>
    <img src="6.png">
</p>
<p align='center'>
    Рисунок 6 - програмі імітує лотерею
</p><br>

<p align='center'>
    <img src="7.png">
</p>
<p align='center'>
    Рисунок 7 - результат виконання програми
</p><br>

Для обробки ситуації, коли ліміт ресурсу обмеження часу ЦП буде вичерпано, я використав функції signal - для обробки сигналів, та функцію alarm, яка зупинить нормальне виконання програми і викликає функцію, яку ми передаємо в параметри. Для того, щоб продемонструвати роботу цих функцій, допишемо цикл між генераціями чисел (рисунок 8) з подальшою компіляцією та виконанням програми (рисунок 9).

<p align='center'>
    <img src="8.png">
</p>
<p align='center'>
    Рисунок 8 - доавання циклу
</p><br>

<p align='center'>
    <img src="9.png">
</p>
<p align='center'>
    Рисунок 9 - результат додавання циклу
</p><br>

Як бачимо, нам вдалося коректно встановити ліміт на час ЦП та обробити випадок, коли ліміт ресурсу вичерпано.

<br>
<hr>

## Завдання 5

Реалізуємо програму згідно з вимогами завдання (рисунок 10) та скомпілюємо.

<p align='center'>
    <img src="10.png">
</p>
<p align='center'>
    Рисунок 10 - програма для копіювання файлів
</p><br>

Протестуємо програму на ліміт розміру файлу. Створимо файл src.txt розміром більше 10 байт та протестуємо програму (рисунок 11).

<p align='center'>
    <img src="11.png">
</p>
<p align='center'>
    Рисунок 11 - програма для копіювання файлів
</p><br>

Як і очікували, отримали помилку пов'язану з превищенням ліміту розміру файла. Тепер зменшимо обсяг файлу і повторимо дії (рисунок 12).

<p align='center'>
    <img src="12.png">
</p>
<p align='center'>
    Рисунок 12 - програма для копіювання файлів
</p><br>

Як бачимо, тепер ніяких помилок нема і вміст файлу src.txt успішно записався у файл dest.txt.

<br>

<hr>

## Завдання 6

Для початку дізнаємось розмір стеку (рисунок 13).

<p align='center'>
    <img src="13.png">
</p>
<p align='center'>
    Рисунок 13 - розмір стеку
</p><br>

Тепер напишемо програму з нескінченною рекурсією, оскільки вона активно використовує стек (рисунок 14).

<p align='center'>
    <img src="14.png">
</p>
<p align='center'>
    Рисунок 14 - програма з рекурсією
</p><br>

Для прискорення виконання програми, зменшимо розмір стеку (рисунок 15) і запустимо програму (16).

<p align='center'>
    <img src="15.png">
</p>
<p align='center'>
    Рисунок 15 - зміна розміру стеку
</p><br>

<p align='center'>
    <img src="16.png">
</p>
<p align='center'>
    Рисунок 16 - результат виконання програми
</p><br>

При досягненні ліміту розміра стеку, програма завершується з помилкою.

<br>

<hr>

## Завдання 7 (по варіантах)

**У мене п'ятий варіант**.<br> 

Отже встановимо ліміт на використання CPU (рисунок 17).

<p align='center'>
    <img src="18.png">
</p>
<p align='center'>
    Рисунок 17 - ліміт по часу на 3 секунди
</p><br>

Далі напишемо програму з нескінченним циклом (рисунок 18) та запустимо її (рисунок 19).

<p align='center'>
    <img src="17.png">
</p>
<p align='center'>
    Рисунок 18 - нескінченний цикл 
</p><br>

<p align='center'>
    <img src="19.png">
</p>
<p align='center'>
    Рисунок 19 - результат виконання програми 
</p><br>

Після встановленого часу, коли ліміт використання CPU буде досягнутий, програма припиняє свою роботу.



