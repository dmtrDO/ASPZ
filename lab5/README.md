<hr>

# <p style="margin: 0; text-align: center;">Лабораторна робота №5</p>

В теоретичній частині до valgrind-практики мене зацікавив один приклад (рисунок 1).

<p align='center'>
    <img src="img/1.png">
</p>
<p align='center'>
    Рисунок 1 - код до прикладу невизначеної поведінки
</p><br>

<p align='justify'>
    Зацікавив просто бо не пригадую, щоб виконував подібні операції. В теорії сказано, що поведінка невизначена і такий вираз може дати різний результат на різних компіляторах. Мені захотілось подивитись результат мого компілятора. Як бачимо у мене gcc 13.3.0 (рисунок 2).
</p>

<p align='center'>
    <img src="img/2.png">
</p>
<p align='center'>
    Рисунок 2 - результат виконання коду
</p><br>

<p align='justify'>
    В результаті (рисунок 2) бачимо результат 22. Тобто спочатку виконались операції з пост- та пре- інкрементами, а потім вже сама операція додавання. Сам компілятор теж пише про те, що операція саме з префіксним інкрементом може бути невизначена. Мені це здалось дивним, тому я поміняв місцями операнди (рисунок 3, 4).
</p>

<p align='center'>
    <img src="img/3.png">
</p>
<p align='center'>
    Рисунок 3 - код зі зміною місцями операндів
</p><br>

<p align='center'>
    <img src="img/4.png">
</p>
<p align='center'>
    Рисунок 4 - результат коду після зміни місцями операндів
</p><br>

<p align='justify'>
    Неочікуваний результат (принаймні для мене). Тобто виходить, що спочатку виконалась операція з пре-інкрементом, після чого а = 11, а потім  пост-інкремент, після якого а = 12 (що дивно, оскільки судячи з першого прикладу, операція з пост-інкрементом повинна була виконатись після операції додавання), і потім операція додавання. А в минулому прикладі виходить, що після постфіксного інкремента на місце операнда стало 11, але при ++а замість 'a' підставилось все одно 10, можливо через те що при першій операції з постфіксним інкрементом спочатку повертається значення змінної, а потім вже збільшується на одиничку (після операції додавання). 
</p>

<br>

<hr>

## <p style="margin: -12px 0 6px 0; text-align: center;">Варіант 5</p>

<br>

> 5. Реалізуйте фрагмент програми з подвійним звільненням пам’яті, який не завжди викликає помилку при виконанні.

<br>

<p align='justify'>
    Наприклад, спочатку виділяємо пам'ять, одразу звільняємо її, потім надаємо користувачу можливість ввести якесь число, якщо число непарне, то нічого не відбувається, а якщо парне, - то повторно звільняємо пам'ять (рисунок 5).
</p>

<p align='center'>
    <img src="img/5.png">
</p>
<p align='center'>
    Рисунок 5 - фрагмент коду згідно з завданням
</p><br>

<p align='justify'>
    Скористаємось таким інструментом як valgrind для налагодження та знаходження помилок при роботі з пам'яттю (рисунок 6, 7).
</p>

<p align='center'>
    <img src="img/6.png">
</p>
<p align='center'>
    Рисунок 6 - компіляція та запуск через valgrind
</p><br>

<p align='center'>
    <img src="img/7.png">
</p>
<p align='center'>
    Рисунок 7 - результат виконання
</p><br>

<p align='justify'>
    Бачиом, що спочатку компілятор попереджає нас, що вказівник ptr може бути використаним після звільнення. Потім, при запуску та введенням парного значення, valgrind видає нам помилку: Invalid free()... (хоча при запуску програми без valgrind ніякої помилки нема).
</p>


